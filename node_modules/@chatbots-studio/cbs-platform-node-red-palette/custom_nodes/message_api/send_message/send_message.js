const axios = require("axios");
const stringify = require("fast-safe-stringify");
const urlJoin = require("url-join");

const {
  envConfig: { messageApiEnvConfig },
} = require("../../../config");
const { exampleJsons } = require("../../../enums");
const { handleNodeError } = require("../../../error");
const {
  createTemplateHelper,
  deleteTemplateHelper,
  getAllTemplatesHelper,
  getTemplateByIdHelper,
  getTemplateNamesListHelper,
  updateTemplateHelper,
} = require("../../../helpers");
const { customLogger } = require("../../../logger");

module.exports = function (RED) {
  "use strict";
  const nodes = {};

  function createResponseWrapper(node, res) {
    var wrapper = {
      _res: res,
    };
    var toWrap = [
      "append",
      "attachment",
      "cookie",
      "clearCookie",
      "download",
      "end",
      "format",
      "get",
      "json",
      "jsonp",
      "links",
      "location",
      "redirect",
      "render",
      "send",
      "sendfile",
      "sendFile",
      "sendStatus",
      "set",
      "status",
      "type",
      "vary",
    ];
    toWrap.forEach(function (f) {
      wrapper[f] = function () {
        node.warn(
          RED._("httpin.errors.deprecated-call", { method: "msg.res." + f })
        );
        var result = res[f].apply(res, arguments);
        if (result === res) {
          return wrapper;
        } else {
          return result;
        }
      };
    });
    return wrapper;
  }

  function SendMessageNode(config) {
    RED.nodes.createNode(this, config);
    const node = this;
    nodes[node.id] = node;

    this.url = `/webhook/${node.id}`;

    this.errorHandler = function (err, req, res, next) {
      node.warn(err);
      res.sendStatus(500);
    };

    this.callback = function (req, res) {
      var msgid = RED.util.generateId();
      res._msgid = msgid;

      res.end();
      node.send([
        ,
        ,
        ,
        {
          _msgid: msgid,
          req: req,
          res: createResponseWrapper(node, res),
          payload: req.body,
        },
      ]);
    };

    node.on("input", async function (msg, send, done) {
      const logger = customLogger(this);

      logger.addParam("_node", "send-message");

      try {
        const env = await messageApiEnvConfig();

        const props = {
          language: RED.util.evaluateNodeProperty(
            config.language,
            config.languageType,
            this,
            msg
          ),
          messageId: RED.util.evaluateNodeProperty(
            config.messageID,
            config.messageIDType,
            this,
            msg
          ),
          templateId: config.templateId,
          traceID: RED.util.evaluateNodeProperty(
            config.traceID,
            config.traceIDType,
            this,
            msg
          ),
          userID: RED.util.evaluateNodeProperty(
            config.userID,
            config.userIDType,
            this,
            msg
          ),
        };

        const allowedEmptyProps = ["messageId"];

        Object.entries(props).forEach(([key, value]) => {
          if (!value && !allowedEmptyProps.includes(key)) {
            throw new Error(`\"${key}\" field is invalid or empty`);
          }
        });

        logger.addParam("userID", props.userID);
        logger.addParam("traceID", props.traceID);

        const [companyId, botId, channel, chatId] = props.userID.split("_");

        const templateVars = {};

        for (const p of config.props[props.templateId]) {
          const { property = null, value = "", valueType = "str" } = p;

          if (property) {
            let propertyValue = RED.util.evaluateNodeProperty(
              value,
              valueType,
              this,
              msg
            );

            // if (typeof propertyValue === "object") {
            //   propertyValue = stringify(propertyValue);
            // }
            templateVars[property] = propertyValue;
          }
        }

        const { language, messageId, templateId } = props;

        const dataToSend = {
          botId,
          callbackKey: node.id,
          channel,
          companyId,
          language,
          receiver: chatId.toString(),
          templateId,
        };

        if (Object.keys(templateVars).length) {
          dataToSend.templateVars = templateVars;
        }

        if (messageId) {
          dataToSend.messageId = messageId;
        }

        const requestOptions = {
          data: stringify(dataToSend),
          method: "POST",
          headers: {
            authorization: env.MESSAGES_API_KEY,
            "content-type": "application/json",
            "x-trace-id": props.traceID,
            "x-user-id": props.userID,
          },
          url: urlJoin(env.MESSAGES_API_URL, "v1/messages"),
        };

        logger.addParam("outUrl", requestOptions.url);
        logger.addParam("request", requestOptions);

        const response = await axios(requestOptions);
        msg = {
          ...msg,
          payload: response.data,
        };

        logger.addParam("statusCode", response.status);
        logger.addParam("response", response.data);

        logger.logInfo();

        send(msg);
        done();
      } catch (error) {
        await handleNodeError(error, logger, this, msg);

        done();
      }
    });

    node.on("close", function () {
      const node = this;
      const { stack = null } = (RED.httpNode && RED.httpNode._router) || {};

      if (stack) {
        stack.forEach(function (route, i, routes) {
          if (
            route.route &&
            route.route.path === node.url &&
            route.route.methods["post"]
          ) {
            routes.splice(i, 1);
          }
        });
      }

      delete nodes[node.id];
    });

    if (RED.settings.httpNodeRoot !== false) {
      if (config.currentTemplateTimer || config.isTimerUsed) {
        RED.httpNode.post(this.url, this.callback, this.errorHandler);
      } else {
        const node = this;
        const { stack = null } = (RED.httpNode && RED.httpNode._router) || {};

        if (stack) {
          stack.forEach(function (route, i, routes) {
            if (
              route.route &&
              route.route.path === node.url &&
              route.route.methods["post"]
            ) {
              routes.splice(i, 1);
            }
          });
        }
      }
    }
  }

  RED.nodes.registerType("send-message", SendMessageNode);

  RED.httpAdmin.delete("/template/:templateId", async function (req, res) {
    const { templateId } = req.params;
    const nodeKey = Object.keys(nodes)[0];

    const response = await deleteTemplateHelper(templateId, nodes[nodeKey]);

    res.json(response);
  });

  RED.httpAdmin.get("/template/:templateId", async function (req, res) {
    const { templateId } = req.params;
    const nodeKey = Object.keys(nodes)[0];

    const response = await getTemplateByIdHelper(templateId, nodes[nodeKey]);

    res.json(response);
  });

  RED.httpAdmin.get("/standard-templates", async function (req, res) {
    const { CHANNEL } = await messageApiEnvConfig();
    const response = exampleJsons[CHANNEL];

    if (!response) {
      return res.json({ error: `No data found for channel ${CHANNEL}` });
    }

    res.json(response);
  });

  RED.httpAdmin.post("/template/:templateId", async function (req, res) {
    const {
      params: { templateId },
      body,
    } = req;
    const nodeKey = Object.keys(nodes)[0];

    const response = await createTemplateHelper(
      { templateId, ...body },
      nodes[nodeKey]
    );

    res.json(response);
  });

  RED.httpAdmin.put("/template/:templateId", async function (req, res) {
    const {
      params: { templateId },
      body,
    } = req;
    const nodeKey = Object.keys(nodes)[0];

    const response = await updateTemplateHelper(
      { templateId, ...body },
      nodes[nodeKey]
    );

    res.json(response);
  });

  RED.httpAdmin.get("/templatesList", async function (req, res) {
    const nodeKey = Object.keys(nodes)[0];

    const { data, error } = await getAllTemplatesHelper(nodes[nodeKey]);

    if (error) {
      return res.json({ error });
    }

    const templateNamesList = await getTemplateNamesListHelper(data);

    res.json({ data: templateNamesList });
  });
};
