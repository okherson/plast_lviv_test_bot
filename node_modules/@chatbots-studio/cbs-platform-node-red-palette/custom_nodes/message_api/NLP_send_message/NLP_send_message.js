const axios = require("axios");
const stringify = require("fast-safe-stringify");
const urlJoin = require("url-join");

const {
  envConfig: { messageApiEnvConfig },
} = require("../../../config");
const { handleNodeError } = require("../../../error");
const { customLogger } = require("../../../logger");

module.exports = function (RED) {
  "use strict";
  const nodes = {};

  function createResponseWrapper(node, res) {
    var wrapper = {
      _res: res,
    };
    var toWrap = [
      "append",
      "attachment",
      "cookie",
      "clearCookie",
      "download",
      "end",
      "format",
      "get",
      "json",
      "jsonp",
      "links",
      "location",
      "redirect",
      "render",
      "send",
      "sendfile",
      "sendFile",
      "sendStatus",
      "set",
      "status",
      "type",
      "vary",
    ];
    toWrap.forEach(function (f) {
      wrapper[f] = function () {
        node.warn(
          RED._("httpin.errors.deprecated-call", { method: "msg.res." + f })
        );
        var result = res[f].apply(res, arguments);
        if (result === res) {
          return wrapper;
        } else {
          return result;
        }
      };
    });
    return wrapper;
  }

  function NLPsendMessageNode(config) {
    RED.nodes.createNode(this, config);
    const node = this;
    nodes[node.id] = node;

    this.url = `/webhook/${node.id}`;

    this.errorHandler = function (err, req, res, next) {
      node.warn(err);
      res.sendStatus(500);
    };

    this.callback = function (req, res) {
      var msgid = RED.util.generateId();
      res._msgid = msgid;

      res.end();
      node.send([
        ,
        ,
        ,
        {
          _msgid: msgid,
          req: req,
          res: createResponseWrapper(node, res),
          payload: req.body,
        },
      ]);
    };

    node.on("input", async function (msg, send, done) {
      const logger = customLogger(this);

      logger.addParam("_node", "NLP-send-message");

      try {
        const env = await messageApiEnvConfig();

        const props = {
          language: RED.util.evaluateNodeProperty(
            config.language,
            config.languageType,
            this,
            msg
          ),
          templateId: config.templateId,
          userID: RED.util.evaluateNodeProperty(
            config.userID,
            config.userIDType,
            this,
            msg
          ),
          traceID: RED.util.evaluateNodeProperty(
            config.traceID,
            config.traceIDType,
            this,
            msg
          ),
          intentId: RED.util.evaluateNodeProperty(
            config.intentId,
            config.intentIdType,
            this,
            msg
          ),
          conversationId: RED.util.evaluateNodeProperty(
            config.conversationId,
            config.conversationIdType,
            this,
            msg
          ),
        };

        Object.entries(props).forEach(([key, value]) => {
          if (!value) {
            throw new Error(`\"${key}\" field is invalid or empty`);
          }
        });

        logger.addParam("userID", props.userID);
        logger.addParam("traceID", props.traceID);

        const [companyId, botId, channel, chatId] = props.userID.split("_");

        const templateVars = {};

        for (const p of config.props[props.templateId]) {
          const { property = null, value = "", valueType = "str" } = p;

          if (property) {
            let propertyValue = RED.util.evaluateNodeProperty(
              value,
              valueType,
              this,
              msg
            );

            // if (typeof propertyValue === "object") {
            //   propertyValue = stringify(propertyValue);
            // }
            templateVars[property] = propertyValue;
          }
        }

        const { conversationId, language, templateId, intentId } = props;

        const dataToSend = {
          botId,
          callbackKey: node.id,
          channel,
          companyId,
          conversationId,
          language,
          receiver: chatId.toString(),
          templateId,
          intentId,
        };

        if (Object.keys(templateVars).length) {
          dataToSend.templateVars = templateVars;
        }

        const requestOptions = {
          data: stringify(dataToSend),
          method: "POST",
          headers: {
            authorization: env.MESSAGES_API_KEY,
            "content-type": "application/json",
            "x-trace-id": props.traceID,
            "x-user-id": props.userID,
          },
          url: urlJoin(env.MESSAGES_API_URL, "v1/messages/nlp"),
        };

        logger.addParam("outUrl", requestOptions.url);
        logger.addParam("request", requestOptions);

        const response = await axios(requestOptions);
        msg = {
          ...msg,
          payload: response.data,
        };

        logger.addParam("statusCode", response.status);
        logger.addParam("response", response.data);

        logger.logInfo();

        send(msg);
        done();
      } catch (error) {
        await handleNodeError(error, logger, this, msg);

        done();
      }
    });

    node.on("close", function () {
      const node = this;
      const { stack = null } = (RED.httpNode && RED.httpNode._router) || {};

      if (stack) {
        stack.forEach(function (route, i, routes) {
          if (
            route.route &&
            route.route.path === node.url &&
            route.route.methods["post"]
          ) {
            routes.splice(i, 1);
          }
        });
      }
      delete nodes[node.id];
    });

    if (RED.settings.httpNodeRoot !== false) {
      if (config.currentTemplateTimer || config.isTimerUsed) {
        RED.httpNode.post(this.url, this.callback, this.errorHandler);
      } else {
        const node = this;

        const { stack = null } = (RED.httpNode && RED.httpNode._router) || {};

        if (stack) {
          stack.forEach(function (route, i, routes) {
            if (
              route.route &&
              route.route.path === node.url &&
              route.route.methods["post"]
            ) {
              routes.splice(i, 1);
            }
          });
        }
      }
    }
  }

  RED.nodes.registerType("NLP-send-message", NLPsendMessageNode);
};
